1:
  type: IDENTIFIER (L:LANGLE expr (L:COMMA expr)* L:RANGLE)? (L:LBRACKET INT|O:STAR L:RBRACKET)*
  member: IDENTIFIER (L:DOT IDENTIFIER)+
  refdef: L:DOLLAR IDENTIFIER
  clone: L:OCTOTHORPE atom
  subscript: IDENTIFIER L:LBRACKET expr L:RBRACKET
  funccall: IDENTIFIER L:LPAREN (expr (L:COMMA expr)*)? L:RPAREN

  atom: INT|FLOAT|STRING|IDENTIFIER
      : (L:LPAREN expr L:RPAREN)
      : type
      : member
      : refdef
      : clone
      : subscript
      : funccall

2:
  ref: O:STAR atom
  sign: (O:PLUS|O:MINUS)+ atom
  logicnot: O:BANG+ atom
  bitnot: O:BITNOT+ atom

  unary: ref
       : sign
       : logicnot
       : bitnot
       : atom

3:
  term: unary (O:STAR|O:SLASH|O:MOD unary)*

4:
  arith: term (O:PLUS|O:DASH term)*

5:
  shift: arith (O:LSHIFT|O:RSHIFT arith)*

6:
  comp: shift (O:LANGLE|O:RANGLE|O:LESSEQUALS|O:GREATEREQUALS shift)*

7:
  equals: comp (O:EQUALS|O:NOTEQUALS comp)*

8:
  bitand: equals (O:BITAND equals)*

9:
  bitxor: bitand (O:BITXOR bitand)*

10:
  bitor: bitxor (O:BITOR bitxor)*

11:
  and: bitor (O:AND bitor)*

12:
  or: and (O:OR and)*

14:
  normassign: (IDENTIFIER O:ASSIGN)* or (L:COMMA (IDENTIFIER O:ASSIGN)* or)*

  assign: (IDENTIFIER O:ASSIGN|A:LSHIFT|A:RSHIFT|A:ADD|A:SUB|A:MUL|A:DIV|A:MOD|A:BITAND|A:BITOR|A:BITXOR)* or

15:
  expr: assign (L:COMMA assign)*

16:
  vardecl: type normassign SEMICOLON
  funcdef: K:FUNCTION IDENTIFIER L:LPAREN (type IDENTIFIER (L:COLON IDENTIFIER)? (L:COMMA type IDENTIFIER (L:COLON IDENTIFIER))*)? L:RETURN L:LBRACE statements L:RBRACE
  structdef: K:STRUCT IDENTIFIER L:LBRACE vardecl* L:RBRACE
  moduledef: K:MODULE IDENTIFIER L:LBRACE modulestmts L:RBRACE
  define: K:DEFINE vardecl
  return: K:RETURN expr?

17:
  modulestmts: funcdef
             : define
             : structdef
             : moduledef
  
  statement: expr SEMICOLON
           : vardecl
           : return
  
  statements: statement*
